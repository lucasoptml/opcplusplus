%% **********
%% CONSTRUCTS
%% **********

% constructs
\chapter{Constructs}
\label{chap:constructs}

\section{opobjects}
\label{sec:opobject}

opobjects are the object oriented class construct in \opCPP.  They may be defined with a number of keywords, the defaults being \opcppK{opclass} and \opcppK{opstruct}.  Most custom syntax in \opCPP\ is related to opobject contexts.

\subsection{categories}

New types of opobjects may be added by specifying user-defined opobject keywords.  These opobject keywords are called categories.  Categories add additional control for syntax and validation, and can help customize the code generated by the \opCPP\ compiler.   The default categories, \opcppK{opclass} and \opcppK{opstruct}, are in place to provide similar syntax to \cpp, while allowing you to write \opCPP\ and \cpp\ code side by side.

\subsection{{\tt opclass}}

\opcppK{opclass} is the default keyword to start a class-based opobject construct.  The syntax for declaring an\opcppK{opclass} is very similar to the \cpp\ \opcppK{class} construct.  Figure \ref{fig:opclass1} shows a simple \opcppK{opclass} declaration.

% fig:opclass1
\begin{opcpp}[label={fig:opclass1},caption={A simple \opcppK{opclass} declaration in \opCPP.}]
// A simple opclass declaration.
opclass classname
{
	//class definition
};
\end{opcpp}

Inheritance for an \opcppK{opclass} is similar to \cpp\ \opcppK{class} inheritance.  Notable differences are that only single inheritance is currently allowed, and visibility keywords are required and not optional.  Figure \ref{fig:opclass2} makes these differences clear.  The member definitions are also slightly different than in \cpp.  This is covered in Section \ref{}.  Finally, as in \cpp, by default everything is declared \opcppK{private}.

% fig:opclass2
\begin{opcpp}[label={fig:opclass2},caption={Examples of valid and invalid \opcppK{opclass} inheritance.}]
// A valid opclass inherited from parentclass.
opclass classname : public parentclass
{
	// class definition
};

// An invalid opclass - multiple inheritance is not allowed.
opclass classname : public parentclass, public parentclassb
{
	// class definition
}

// An invalid opclass - missing visibility keyword.
opclass classname : parentclass
{
	// class definition
}
\end{opcpp}

\subsection{{\tt opstruct}}

The second default opobject category is \opcppK{opstruct}.  \opcppK{opstruct} is the keyword for \opCPP\ structures.  As an obobject category, the syntax and restrictions match those of \opcppK{opclass} entirely.  The only difference is that, just as in \cpp, its default member visibility is \opcppK{public} instead of \opcppK{private}.  Figure \ref{fig:opstruct1} shows an example of a simple \opcppK{opstruct}.

% fig:opstruct1
\begin{opcpp}[label={fig:opstruct1},caption={A simple \opcppK{opstruct} declaration in \opCPP.}]
// A simple opstruct declaration.
opstruct classname
{
	int a;
	int b;
};

\end{opcpp}

\subsection{user-defined opobjects}

Users may define their own opobject categories.  These simply take the form of additional keywords.  These extra keywords are syntax validated by the compiler, and placement of category keywords in invalid contexts is disallowed.  These options can be enabled via the commandline or through dialects.  See Section \ref{} for instructions on doing this.  Figure \ref{fig:udopobject2} shows an example of a user-defined obobject category.

% fig:udopobject2
\begin{opcpp}[label={fig:udopobject2},caption={A user-defined opobject category declaration called \opcppK{nativeclass}.}]
// A user-defined opoboject category called nativeclass.
nativeclass classname
{
	// class definition
};
\end{opcpp}

\section{{\tt openum}}

In \opCPP, just as we have special keywords for opobjects, we also have a custom syntax for enumerations.  Parsed enumerations are called \opcppK{openum}s, and have the same syntax as \cpp\ \opcppK{enum}s.  Using an \opcppK{openum} instead of a \cpp\ \opcppK{enum} allows \opCPP\ to generate additional code for the enumeration.  Figure \ref{fig:openum1} shows some example \opcppK{openum} declarations.

\begin{opcpp}[label={fig:openum1},caption={Some simple \opcppK{openum} declarations in \opCPP.}]
// A simple Color openum declaration.
// Notice the comma after the entry "Blue" is allowed.
openum Color
{
	Red,
	Blue,
};

// A simple musical genre openum declaration.
// Notice there is no comma after the entry "Country".
openum Genre
{
	Jazz,
	Classical,
	Country
};
\end{opcpp}

\section{{\tt state}}

One special opobject context construct in \opCPP\ is the \opcppK{state}.  This is an alternative to writing switch statements based on the internal state of an object.  The \opcppK{state} construct is used to provide a more descriptive form for state switching code.  Each \opcppK{state} can contain function definitions.  Functions with matching names and signatures will be redirected when called based on the internal state of the object.  In Figure \ref{fig:state1}, calls to the function \opcppK{clicked} will be routed through the internal state.

\begin{opcpp}[label={fig:state1},caption={An example of using the \opcppK{state} construct in \opCPP.}]
// An opclass definition with state support.
opclass ButtonClass
{
	state buttonup
	{
		void clicked()
		{
			// go down
		}	
	}
	
	state buttondown
	{
		void clicked()
		{
			// stay down
		}
	}
};
\end{opcpp}

By default, the internal \opcppK{state} is tracked by a hidden data member, and may be set using the \opcppK{setinternalstate} function.  Figure \ref{fig:state2} shows how to change the \opcppK{state} of the \opcppK{ButtonClass} defined in Figure \ref{fig:state1}.

\begin{opcpp}[label={fig:state2},caption={Changing the internal \opcppK{state} of an instance of \opcppK{ButtonClass} defined in Figure \ref{fig:state1}.}]
ButtonClass b;

b.setinternalstate(ButtonClass::buttonup);
b.clicked();
\end{opcpp}




